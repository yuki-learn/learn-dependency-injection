# 依存注入のアンチパターン


## コントロール・フリーク
**コントロール・フリーク (Control freak)** は合成基点ではないところで揮発性依存に依存することで発生するアンチパターン。<br>

例えば、揮発性依存に対して`new`演算子でオブジェクトを生成してるのはコントロールフリークに該当する。
```cs
public class HomeController : Controller
{
    // HomeControllerは内部で揮発性依存であるProductServiceを直接生成してしまっている。
    // ※ ProductServiceはDBを扱うRepository(揮発性依存)に依存している
    // それによって密結合してる。
    public ViewResult Index()
    {
        var service = new ProductService();

        var products = service.GetProducts();
        return this.View(products);
    }
}
```


new演算子を使うことは、オブジェクトを生成したコードがそのオブジェクトの生存管理を行い、他のコードに対してこのオブジェクトへの介入を行えないようにする、というのを明示的に宣言しているようなもの。<br>
直接、揮発性依存のオブジェクトを制御したらそれは密結合になる。


**※ファクトリを使っても結局、ファクトリで揮発性依存を生成していたら同じこと**


### 揮発性依存？
アプリケーションに対して充分な基盤を提供できない、安定していない依存。

以下に当てはまるやつを本書では「揮発性依存」としている

* 対象の依存を導入してアプリケーションを稼働させるには実行環境に対する設定や調整などが必要なやつ。
    * DBは実行環境によって異なるので、DBを扱うリポジトリなどは揮発性依存となる。
* 対象の依存の具象クラスがまだ用意されていない
* 対象の依存に非決定的な振る舞い(同じ入力に対して異なる結果を返す)が含まれている
    * ランダム値とか使ってやるやつ。(System.Randam)


### 安定依存?
安定依存のオブジェクトをnew使って生成するのは問題ない。<br>
安定依存のとはどんなものか。

* そのクラスや、モジュールが最初から存在している
    * .NETで開発する際の基本クラス・ライブラリ(BCL)など
* 新しいバージョンが出ても破壊的変更がないことを期待できる。
* その型には決定的アルゴリズムが含まれている
* 

### コントロールフリークがもたらす負の影響
* 事前に用意しておいた複数の依存の中から1つを使うようにアプリケーションで構成しても、それらの依存を好きなように置き換えることはできない。(再度、コンパイルが必要)
* 依存を利用しているモジュールの再利用が難しい。
    * 例えば、ASP.NET Coreのライブラリに依存するモジュールがあったとして、そのモジュールを持ち込もうとしてるアプリが.NET Coreに依存できなかったり、すべきでない場合はそのモジュールを使えない。
* 密結合してるから、複数人で開発するのがやりにくくなる。
* テスト容易性が損なわれる。
    * 直接生成してるからテスト・ダブルを依存の代わりとして使えなくなる。

### コントロールフリークをリファクタリング
* 抽象に対してプログラミングすることを確実に行うようにする。
## サービス・ロケータ

### サービス・ロケータの欠点
サービス・ロケータがアンチパターンである理由は以下2個の欠点があるため。

1. サービス・ロケータを利用するクラスはサービス・ロケータを余分な依存として自身のモジュールに持ち込まないといけない。
    * 例えば、`ProductService`クラスがサービス・ロケータを使用して`IProductRepository`への依存を取得しているとしたら、`IProductRepository`の他に、サービス・ロケータへの依存も必要になってしまう。
    * 更に、そのサービス・ロケータが別モジュールに格納されているなら、そのモジュールにも依存することになる。
    * コンストラクタ注入にすればサービス・ロケータへの依存が必要なくなるのでコンストラクタ注入を使うべき。
2. サービス・ロケータを利用するクラスは内部で利用している依存がなんなのかを外部から隠してしまう。
    * 例えば、`var service = new ProductService()`とコードを書いたときVisual Studioなどでマウスオーバーしても、どんな依存が必要なのか利用する側は知ることができない。更に、サービス・ロケータへの登録を怠ると、実行時にエラーになってしまう。
    * コンストラクタ注入にすれば、利用する側でどんな依存が必要なのかわかるし、間違っていた場合コンパイルエラーが出るので安全。


**DIコンテナを使っていたとしても、クラス内で必要な依存を得るためにDIコンテナを介して取得していたら、それもサービス・ロケータを持ち込んでいることになるので注意。**

合成基点内でしか使われないDIコンテナはサービス・ロケータにならない。その場合のDIコンテナは基盤のコンポーネントになるから。



## アビエント・コンテキスト(Ambient Context)

**アビエント・コンテキスト(Ambient Context)** とはstaticなメソッドやプロパティを利用することで合成基点の外で揮発性依存(volatile dependency)へのグローバルなアクセスや振る舞いをアプリケーション・コードに提供するもの。


アビエント・コンテキストの悪いコード
```cs
public string GetWeIcomeMessage()
{
    ITimeProvider provider = Timeprovider.Current;
    DateTime now = provider.Now;

    string partOfDay = now.Hour < 6 ? "night" : "day" ;

    return $"Good {partOfDay}.";
}
```

`Timeprovider`はシステムの現在時刻を取得することを抽象化したもの。


### アビエント・コンテキストの欠点

* 依存が隠れてしまう
* テストが難しくなる
* コンテキスト(文脈)をもとに依存を変えるのが難しくなる。
* 依存の初期化と依存の使用とのあいだに一時的結合(Temporal Coupling)


#### 依存が隠れてしまう
どこからでも依存にアクセスできるようになるので、その依存は外部から隠れるようになってしまう。アビエント・コンテキストを利用しているクラスが多くの依存持っていたとしても、それが隠れてしまう。 <br>

コンストラクタ経由での過度な注入(constructor over-injection)を避けるためにアビエント・コンテキストが使われることがある。そもそも過度な注入してるのはクラスがいろんなことをしていて**単一責任の原則**に違反してる可能性があるので、アビエント・コンテキストを使うのではなくクラスの設計を見直す必要がある。

#### テストが難しくなる
静的なクラスから依存を取得してるから単純にテストしにくい。<br>
やはりコンストラクタなどから注入して利用するほうが良い。


#### コンテキストをもとに依存を変えるのが難しくなる
同じ抽象の依存を必要とする異なるクラスに対して異なる実装クラスのオブジェクトを渡すのが難しくなる。

ロガーの例
```cs
private static readonly ILog Logger = LogManager. GetLogger(typeof(MessageGenerator));
```
この`GetLogger`メソッドでは`ILog`型のオブジェクトに対して異なる実装クラスのオブジェクトを提供できるようになっていて、意図する実装クラスの型を渡すように依存を利用するコードに要求するようになっている。<br>
これをしてしまうとアビエント・コンテキストを利用するコードに対して不要な複雑さを課すことになってしまう。


#### 依存の初期化と依存の使用とのあいだに一時的結合
アビエント・コンテキストを利用することはその依存に対して一時的でも密結合を強いることになる。

なので合成基点で初期化をしていないと依存を利用するクラスがアビエント・コンテキストから依存を取得したときに初めて、その処理は失敗するようになる。<br>
本来は初期化されていない時点でエラーになってアプリケーションが失敗するべき。


## 制約に縛られた生成(Constrained Construction)
遅延バインディングをするために、特定の抽象に対する実装クラスがすべて同じようなコンストラクタを持つように強要されること


例えば実行時に接続文字列が決まるようなリポジトリのインターフェイスがあったとき、実装はこうなって、
`IProductRepository`を使うリポジトリは全部同じシグネチャのコンストラクタが必要になってしまう。

```cs
public class SqlProductRepository : IProductRepository
{
    public SqlProductRepository(string connectionStr) 
    {
    }
}

public class AzureProductRepository : IProductRepository
{
    public AzureProductRepository(string connectionStr) 
    {
    }
}
```

遅延バインディングはコードが複雑になりがちなのでできれば使わないほうがいい。


### 解決方法

DIコンテナを使う。DIコンテナはリフレクションを使ってコンストラクタのシグネチャを分析するから、合成基点がクラスのコンストラクタがなにに依存しているかを知らなくて済む。<br>
DIコンテナは抽象と実装クラスの紐づけを登録するコードを列挙するだけでいい。